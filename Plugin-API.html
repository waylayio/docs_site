<html lang="en">

<head>
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Waylay.io Documentation</title>

    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/jquery-ui.css" rel="stylesheet">
    <link href="css/jquery.tocify.css" rel="stylesheet">
    <link href="css/prettify.css" type="text/css" rel="stylesheet" />
    <link href="css/freelancer.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="http://www.waylay.io/favicon.png">
    <link rel="stylesheet" href="css/simplemenu.css">
    </head>

    <body id="page-top" class="index">
        
        
    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-fixed-top" style="padding: 0;">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
<!--                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>-->
                <a class="navbar-brand" href="http://docs.waylay.io/">docs.waylay.io</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- THIS IS THE MENU --> 

        <div class="mobilenav"> 
  <li><a href="Waylay-REST-API-documentation.html">REST API</a></li> 
  <li><a href="Plugin-API.html">Sensors & Actuators</a></li> 
  <li><a href="Submitting-and-fetching-data.html">Broker & Storage</a></li> 
  <li><a href="Architecture.html">Architecture</a></li> 
  <li><a href="Waylay-starters-guide.html">Starter's Guide</a></li> 

</div> 

        <!-- THIS IS THE ICON --> 

        <a href="javascript:void(0)" class="icon"> 
           <div class="hamburger"> 
             <div class="menui top-menu"></div> 
             <div class="menui mid-menu"></div> 
             <div class="menui bottom-menu"></div> 
           </div> 
        </a>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container-fluid -->
    </nav>
        
        
        
        
        
        
        <div class="container-fluid">
        <div class="row-fluid" style="margin-top: 60px;">
        <div class="col-sm-3" style=" padding-left: 0; margin-left: -15px;">
        <div id="toc" class="tocify"></div>
        
        </div>
            <div class="col-sm-9"><h1 id="plugin-api-documentation">Plugin API documentation</h1>
<h2 id="introduction">Introduction</h2>
<p>waylay is a cloud-based agent architecture that observes its environment via <strong>software-defined sensors</strong> and acts on its environment through <strong>software-defined actuators</strong>. A (very) high level blog about it you can find here <a href="http://www.waylay.io/when-iot-meets-artificial-intelligence">blog</a>.</p>
<p>In short, if you implement a weather sensor, it should return a state such as “Rain” or “Sunny”, but it can as well provide information (rawData) such as temperature, humidity etc. Every sensor must either return <strong>state</strong> or <strong>rawData</strong> (it can also return both). Obviously, in order to execute a sensor, you will need some input, like <em>city</em>. How to declare what you need in the plug, and how the framework will provide this input to the sensor will be explained later in the document.</p>
<p>For the actuator implementation, there is no need to return any data, you just need to fire a script and that’s it, this can be an SMS, mail, tweet, REST call or any other thing.</p>
<p>Actuator must be attached to sensors or gates, and it gets triggered when a particular condition is met. That condition can be a state or the state change of a sensor or gate. That implies that <strong>only sensors that return states can be linked to actuators</strong>.</p>
<p>Note: there is also possibility to write <strong>java based plugs, but this feature is only supported in OEM package</strong>. Java based plugs can be of your interest in case you want to write complex mathematical calculations which can’t be handled by the Functional node (described further in the document). For more information how to write such plugs, please e-mail to info@waylay.io</p>
<h2 id="javascript-plugs">Javascript plugs</h2>
<p>Via waylay platform you can write plugins in javascript. This is a sensor editor window that you get in the app:</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/waylayio/documentation/master/images/sensorview.png" class="img-responsive"  alt="Sensor view" />
<p class="caption">Sensor view</p>
</div>
<p>If you start by clicking “Create Sensor”, you can see the following script created for you:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// sensors should never throw exceptions but instead send an error back</span>

<span class="kw">if</span>(<span class="ot">options</span>.<span class="ot">requiredProperties</span>.<span class="fu">testProperty1</span>) {
  <span class="kw">var</span> randomValue = <span class="ot">Math</span>.<span class="fu">random</span>();
  value = {
    <span class="dt">observedState</span>: randomValue &gt; <span class="fl">0.5</span> ? <span class="st">&quot;hello&quot;</span> : <span class="st">&quot;world&quot;</span>,
    <span class="dt">rawData</span>: {  <span class="dt">message</span>: <span class="st">&quot;message&quot;</span>, <span class="dt">x</span>: <span class="fl">2.34</span>, <span class="dt">random</span>: randomValue, <span class="dt">property</span>: <span class="ot">options</span>.<span class="ot">requiredProperties</span>.<span class="fu">testProperty1</span>}
  };
  <span class="fu">send</span>(<span class="kw">null</span>, value);
}<span class="kw">else</span>{
  <span class="fu">send</span>(<span class="kw">new</span> <span class="fu">Error</span>(<span class="st">&quot;Missing property testProperty1&quot;</span>));
}</code></pre>
<p>As you can see, this is just simple javascript, nothing fancy. The only thing you need to know at this point is that these scripts will be executed by a Node.js server, somewhere in the cloud. More precisely Node.js 4.x LTS. For details on supported ES6 api you can visit <a href="http://node.green/">node.green</a>.</p>
<p>Every script is executed in the sandbox environment with a number of packages pre-installed. You can simply access them from the script, no need to require them. You have access to these (and only these) NPM packages:</p>
<ul>
<li>Q as Q,</li>
<li>cheerio as cheerio,</li>
<li>request as request,</li>
<li>XMLHttpRequest as xhr,</li>
<li>google cloud messaging as gcm,</li>
<li>underscore as __, -note a double underscore</li>
<li>unirest as unirest,</li>
<li>twilio as twilio,</li>
<li>mysql as mysql,</li>
<li>mssql as mssql,</li>
<li>postgres as pg,</li>
<li>mqtt as mqtt,</li>
<li>twitter as twitter,</li>
<li>console as console,</li>
<li>jsonPath as jsonPath,</li>
<li>handlebarsjs as handlebarsjs,</li>
<li>coap as coap,</li>
<li>jsforce (salesforce) as jsforce,</li>
<li>nodeHive as nodeHive,</li>
<li>odoo (openERP) as odoo,</li>
<li>async as async (from sandbox 0.8.8),</li>
<li>ftp as FTPClient (from sandbox 0.8.10),</li>
<li>concat-stream as concat (from sandbox 0.8.10),</li>
<li>waylay util package as waylayUtil</li>
</ul>
<p>In case you need more libraries, let us now at support@waylay.io.</p>
<p>Important thing to mention is that your script (both for sensors and actuators) <strong>MUST send back a value</strong>, regardless whether it was successful or not. So try to catch issues and send them back if you want. To send things back, call the method <em>send()</em>. If you call it without arguments, that is fine, but in case that this was a sensor, well then it is not that great. If you need a working example, just click new sensor or new actuator in the app and editor with default implementation will appear on the screen.</p>
<p>In case of a sensor implementation, you want to send back a result, so you must call a method <em>send(null, value)</em>, where value is a JSON object with:</p>
<ul>
<li>observedState (string)</li>
<li>rawData (JSON with key:value pairs) Note that if you want to send a valid response back, the fist argument <em>must</em> be a <em>null</em>, otherwise, the framework will treat a first argument as the error. In case you wonder why, well, let us just say that we try to be compatible to <a href="http://en.wikipedia.org/wiki/JSON-RPC">JSON-RPC spec</a></li>
</ul>
<p>For instance, let’s look at the following code:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> randomValue = <span class="ot">Math</span>.<span class="fu">random</span>(); 
<span class="kw">var</span> state;
<span class="kw">if</span>(randomValue &gt; <span class="fl">0.85</span>)
  state = <span class="st">&quot;ONE&quot;</span>;
<span class="kw">else</span> <span class="kw">if</span>(randomValue &gt; <span class="fl">0.7</span>)
  state = <span class="st">&quot;TWO&quot;</span>;
<span class="kw">else</span> <span class="kw">if</span>(randomValue &gt; <span class="fl">0.55</span>)
  state = <span class="st">&quot;THREE&quot;</span>;
<span class="kw">else</span> <span class="kw">if</span>(randomValue &gt; <span class="fl">0.4</span>)
  state = <span class="st">&quot;FOUR&quot;</span>;
<span class="kw">else</span> <span class="kw">if</span>(randomValue &gt; <span class="fl">0.25</span>)
  state = <span class="st">&quot;FIVE&quot;</span>;
<span class="kw">else</span> 
  state = <span class="st">&quot;SIX&quot;</span>;
value = {  
    <span class="dt">observedState</span>:  state, 
    <span class="dt">rawData </span>: {  <span class="dt">random</span>: randomValue}  
}; 
<span class="fu">send</span>(<span class="kw">null</span>,value);</code></pre>
<p>Note that you <strong>always must return the value from the script</strong>. In this example, this sensor will roll the dice, return one of the six states, and also return a random value. Random value can later been access via the RAW Data context (see below). This sensor is also handy if you want to get familiar with boolean gates or if you want to test formula computation using a Function node.</p>
<p>Below you see an example of a result of a sensor invocation returned by the waylay webapp: <img src="https://raw.githubusercontent.com/waylayio/documentation/master/images/sensorResult.png" class="img-responsive"  /></p>
<p>If you want to send an error with errorMessage, just call <code>send(errorMessage)</code>.</p>
<h2 id="metadata">Metadata</h2>
<p>As part of a sensor/actuator plugin definition, you also need to provide metadata. If you use waylay editor, metadata will be created automatically. For sensor plugins the following metadata needs to be defined:</p>
<ul>
<li><em>Name</em>: name of the sensor</li>
<li><em>Version</em>: three-digit version number.</li>
<li><em>Author</em>: author of the sensor.</li>
<li><em>Category</em>: sensors below to categories that group similar sensors. If the category does not exist yet, it will be created.</li>
<li><em>Documentation URL</em>: URL to external documentation for the sensor.</li>
<li><em>Icon URL</em>: URL to the icon that will be used in the webapp in combination with the sensor.</li>
<li><em>States</em>: define the states that the sensor can return to the node in your logic.</li>
<li><em>Properties</em>: inputs required to invoke the sensor.</li>
<li><em>Raw data</em>: raw data returned by the sensor.</li>
<li><em>Description</em>: Description of the sensor.</li>
</ul>
<p>For actuator plugins, the following metadata needs to be defined:</p>
<ul>
<li><em>Name</em>: name of the actuator</li>
<li><em>Version</em>: three-digit version number.</li>
<li><em>Author</em>: author of the actuator.</li>
<li><em>Category</em>: actuators below to categories that group similar actuators. If the category does not exist yet, it will be created.</li>
<li><em>Documentation URL</em>: URL to external documentation for the actuator.</li>
<li><em>Icon URL</em>: URL to the icon that will be used in the webapp in combination with the actuator.</li>
<li><em>Properties</em>: inputs required to invoke the actuator.</li>
<li><em>Description</em>: Description of the actuator.</li>
</ul>
<p>These metadata of the sensors and actuators are also exposed over the REST interface.</p>
<p>For instance, this is a REST response of one sensor:</p>
<pre class="sourceCode json"><code class="sourceCode json">    <span class="fu">{</span><span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;StockPrice&quot;</span><span class="fu">,</span>
        <span class="dt">&quot;description&quot;</span><span class="fu">:</span> <span class="st">&quot;Stock exchange sensor, stock price value&quot;</span><span class="fu">,</span>
        <span class="dt">&quot;author&quot;</span><span class="fu">:</span> <span class="st">&quot;Veselin&quot;</span><span class="fu">,</span>
        <span class="dt">&quot;version&quot;</span><span class="fu">:</span> <span class="st">&quot;1.0.1&quot;</span><span class="fu">,</span>
        <span class="dt">&quot;iconURL&quot;</span><span class="fu">:</span> <span class="st">&quot;http://app.waylay.io/icons/stock.png&quot;</span><span class="fu">,</span>
        <span class="dt">&quot;documentationURL&quot;</span><span class="fu">:</span> <span class="st">&quot;&quot;</span><span class="fu">,</span>
        <span class="dt">&quot;category&quot;</span><span class="fu">:</span> <span class="st">&quot;Stock&quot;</span><span class="fu">,</span>
        <span class="dt">&quot;states&quot;</span><span class="fu">:</span> <span class="ot">[</span>
            <span class="st">&quot;Below&quot;</span><span class="ot">,</span>
            <span class="st">&quot;Above&quot;</span>
        <span class="ot">]</span><span class="fu">,</span>
        <span class="dt">&quot;configuration&quot;</span><span class="fu">:</span> <span class="ot">[</span>
            <span class="fu">{</span>
                <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;threshold&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;DOUBLE&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;mandatory&quot;</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span>
                <span class="dt">&quot;sensitive&quot;</span><span class="fu">:</span> <span class="kw">false</span>
            <span class="fu">}</span><span class="ot">,</span>
            <span class="fu">{</span>
                <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;stock&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;STRING&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;mandatory&quot;</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span>
                <span class="dt">&quot;sensitive&quot;</span><span class="fu">:</span> <span class="kw">false</span>
            <span class="fu">}</span>
        <span class="ot">]</span>
        <span class="st">&quot;rawData&quot;</span><span class="er">:</span> <span class="ot">[</span>
            <span class="fu">{</span>
                <span class="dt">&quot;parameter&quot;</span><span class="fu">:</span> <span class="st">&quot;volume&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;dataType&quot;</span><span class="fu">:</span> <span class="st">&quot;double&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;collectedType&quot;</span><span class="fu">:</span> <span class="st">&quot;instant&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;unit&quot;</span><span class="fu">:</span> <span class="st">&quot;double&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;isObject&quot;</span><span class="fu">:</span> <span class="kw">true</span>
            <span class="fu">}</span><span class="ot">,</span>
            <span class="fu">{</span>
                <span class="dt">&quot;parameter&quot;</span><span class="fu">:</span> <span class="st">&quot;high&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;dataType&quot;</span><span class="fu">:</span> <span class="st">&quot;double&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;collectedType&quot;</span><span class="fu">:</span> <span class="st">&quot;instant&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;unit&quot;</span><span class="fu">:</span> <span class="st">&quot;double&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;isObject&quot;</span><span class="fu">:</span> <span class="kw">true</span>
            <span class="fu">}</span><span class="ot">,</span>
            <span class="fu">{</span>
                <span class="dt">&quot;parameter&quot;</span><span class="fu">:</span> <span class="st">&quot;low&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;dataType&quot;</span><span class="fu">:</span> <span class="st">&quot;double&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;collectedType&quot;</span><span class="fu">:</span> <span class="st">&quot;instant&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;unit&quot;</span><span class="fu">:</span> <span class="st">&quot;double&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;isObject&quot;</span><span class="fu">:</span> <span class="kw">true</span>
            <span class="fu">}</span><span class="ot">,</span>
            <span class="fu">{</span>
                <span class="dt">&quot;parameter&quot;</span><span class="fu">:</span> <span class="st">&quot;price&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;dataType&quot;</span><span class="fu">:</span> <span class="st">&quot;double&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;collectedType&quot;</span><span class="fu">:</span> <span class="st">&quot;instant&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;unit&quot;</span><span class="fu">:</span> <span class="st">&quot;double&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;isObject&quot;</span><span class="fu">:</span> <span class="kw">true</span>
            <span class="fu">}</span><span class="ot">,</span>
            <span class="fu">{</span>
                <span class="dt">&quot;parameter&quot;</span><span class="fu">:</span> <span class="st">&quot;moving_average&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;dataType&quot;</span><span class="fu">:</span> <span class="st">&quot;double&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;collectedType&quot;</span><span class="fu">:</span> <span class="st">&quot;computed&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;unit&quot;</span><span class="fu">:</span> <span class="st">&quot;double&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;isObject&quot;</span><span class="fu">:</span> <span class="kw">true</span>
            <span class="fu">}</span><span class="ot">,</span>
            <span class="fu">{</span>
                <span class="dt">&quot;parameter&quot;</span><span class="fu">:</span> <span class="st">&quot;percent&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;dataType&quot;</span><span class="fu">:</span> <span class="st">&quot;double&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;collectedType&quot;</span><span class="fu">:</span> <span class="st">&quot;instant&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;unit&quot;</span><span class="fu">:</span> <span class="st">&quot;double&quot;</span><span class="fu">,</span>
                <span class="dt">&quot;isObject&quot;</span><span class="fu">:</span> <span class="kw">true</span>
            <span class="fu">}</span>
        <span class="ot">]</span>
    <span class="fu">}</span></code></pre>
<h2 id="context">Context</h2>
<p>Every plug (both actuator and sensor) can access the context. Why is that needed? Let’s imagine that you want to create a Mail actuator. You will need some information to create an email (subject, content, from, to etc…), and you will need API keys(if you use Mandrill for instance) or SMTP server settings. Plug should be able to tell this to the framework, and that is partially done via the metadata properties as described above. Basically there are four ways plugs can access additionally information at runtime:</p>
<ul>
<li>using metadata to define properties required</li>
<li>accessing global settings (e.g. API keys etc..)</li>
<li>runtime data (measurements)</li>
<li>task context</li>
</ul>
<h3 id="properties">Properties</h3>
<p>These properties are normally provided to the script at configuration time. Typical examples of properties are URLs, API keys or connection settings. For instance, in the code you retrieve them like this:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> url = <span class="ot">options</span>.<span class="ot">requiredProperties</span>.<span class="fu">url</span></code></pre>
<p>You are also required to provide this info in the metadata of the plug (right hand side of the editor), i.e. these Required Properties are not automatically parsed from the JavaScript.</p>
<h3 id="global-settings">Global settings</h3>
<p>You can also declare global settings which are available to sensors and actuators. These settings are visible in the profile page. This way you can for instance declare API keys that rarely change. When you define sensor or actuator, you can access these settings this way (where you need to replace the KEY with the exact key you have declared before):</p>
<p><code>options.globalSettings.KEY</code></p>
<p>for instance you can write a code that requires a token like this:</p>
<p><code>var token = options.requiredProperties.token || options.globalSettings.token</code></p>
<p>This way you can decide whether you want to provide a token at the time you start a task from a template, or you want to declare it in the global settings.</p>
<h3 id="raw-data">Raw Data</h3>
<p>Every plug can access raw data at runtime, even when that raw data was collected by another sensor. The only limitation is that you need to know the name of the node that you want to get the data from.</p>
<p>The raw data is provided in the form <code>options.rawData[node_name]</code> For instance, if you want to get a temperature of the node Home, you would need to get it like this:</p>
<pre><code>options.rawData.Home.temperature</code></pre>
<p>Now you can combine first two things together, so ask at configuration time a node name and then ask for temperature, by declaring that you need a node name in the Required Properties of the webscript:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> temperature, nodeName = <span class="ot">options</span>.<span class="ot">requiredProperties</span>.<span class="fu">node</span>;
<span class="kw">if</span>(nodeName &amp;&amp; <span class="ot">options</span>.<span class="fu">rawData</span>[nodeName]){
  temperature = <span class="ot">options</span>.<span class="fu">rawData</span>[nodeName].<span class="fu">temperature</span>;
}</code></pre>
<p>Next to raw data that comes directly out of the sensor call, there are two more additional sources of information that you can retrieve. See below:</p>
<h4 id="node-related-raw-data">Node related raw data</h4>
<p>You can also access the current state and the last execution time of the sensor:</p>
<ul>
<li><code>options.rawData[&lt;nodeName&gt;].state</code> and</li>
<li><code>options.rawData[&lt;nodeName&gt;].collectedTime</code> (in mills)</li>
</ul>
<p>This is useful in case you want for instance to do a sequence computation on the states of the nodes, for more info, see later section on this.</p>
<h4 id="actuator-related-raw-data">Actuator related raw data</h4>
<p>Similar to raw data context, an actuator also can push some (limited) results back to the context. This is <em>not ideal</em>, but in case you need this, let me directly show you the code of one possible actuator implementation, that is only sending JSON object:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">send</span>(<span class="kw">null</span>, {<span class="dt">message</span>: <span class="st">&quot;hello world&quot;</span>});</code></pre>
<p>Notice that I was sending back value with a message. Normally, actuators are “fire and forget” by calling only <em>send()</em> , but this one is sending back a value - attaching the result in the context to the node to which this actuator belongs!</p>
<p>Later, you might want to do restore with this backup file:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> nodeName = <span class="ot">options</span>.<span class="ot">requiredProperties</span>.<span class="fu">node</span>;
<span class="kw">if</span>(!<span class="ot">options</span>.<span class="fu">actuatorData</span> || !<span class="ot">options</span>.<span class="fu">actuatorData</span>[nodeName]){
    <span class="ot">console</span>.<span class="fu">info</span>(<span class="st">&quot;nothing to do&quot;</span>);
    <span class="fu">send</span>();
}
<span class="kw">else</span>{
    <span class="kw">var</span> value = <span class="ot">options</span>.<span class="fu">actuatorData</span>[nodeName].<span class="fu">message</span>; 
    <span class="co">/*you get back &quot;hello world&quot; </span>
<span class="co">    .... your code goes here */</span>
    <span class="fu">send</span>();
}</code></pre>
<p>Note: we will learn later how do the same with one liner, using <strong>waylay utility package</strong>.</p>
<h3 id="task-data">Task Data</h3>
<p>In the task context, you can retrieve the following task-related data:</p>
<ul>
<li>resource name (task resource name)</li>
<li>task ID (task ID)</li>
<li>node name (node name of the sensor to which this call is attached at the moment of execution)</li>
</ul>
<p>In your plug code, you access these settings this way:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">options</span>.<span class="ot">task</span>.<span class="fu">RESOURCE</span>
<span class="ot">options</span>.<span class="ot">task</span>.<span class="fu">TASK_ID</span>
<span class="ot">options</span>.<span class="ot">task</span>.<span class="fu">NODE_NAME</span></code></pre>
<p>For instance, if you want to create an actuator that would control the running task (please see REST documentation for more info), this is how you can do it:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> taskID = <span class="ot">options</span>.<span class="ot">requiredProperties</span>.<span class="fu">taskId</span> || <span class="ot">options</span>.<span class="ot">task</span>.<span class="fu">TASK_ID</span>;
<span class="kw">var</span> command = <span class="ot">options</span>.<span class="ot">requiredProperties</span>.<span class="fu">command</span>;
<span class="kw">var</span> username =  <span class="ot">options</span>.<span class="ot">globalSettings</span>.<span class="fu">API_KEY</span>;
<span class="kw">var</span> password = <span class="ot">options</span>.<span class="ot">globalSettings</span>.<span class="fu">API_PASS</span>;

<span class="ot">request</span>.<span class="fu">post</span>(
    <span class="st">&#39;https://&#39;</span>+ username + <span class="st">&#39;:&#39;</span> + password +<span class="st">&#39;@app.waylay.io/api/tasks/&#39;</span>+taskID+<span class="st">&#39;/command/&#39;</span>+command,
    <span class="kw">function</span> (error, response, body) {
        <span class="kw">if</span> (!error &amp;&amp; <span class="ot">response</span>.<span class="fu">statusCode</span> == <span class="dv">200</span>) {
            <span class="fu">send</span>();
        } <span class="kw">else</span>
            <span class="fu">send</span>(<span class="kw">new</span> <span class="fu">Error</span>(<span class="st">&quot;Error executing the action&quot;</span>));
    }
);</code></pre>
<p>Note that this way you can call any REST waylay call. The script above will either start or stop a task (command input), while the task ID can either come from the input param, or if not provided, it will act on the current task. This way, for instance, you can stop the task when a particular condition is met.</p>
<h3 id="node-data">Node Data</h3>
<p>In the node context, you can retrieve the following node-related data:</p>
<ul>
<li>resource name (node resource name, in case it is defined it will be different from the resource name on the task level)</li>
<li>node name (node name of the sensor to which this call is attached at the moment of execution)</li>
</ul>
<p>In your plug code, you access these settings this way:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">options</span>.<span class="ot">node</span>.<span class="fu">NAME</span>
<span class="ot">options</span>.<span class="ot">node</span>.<span class="fu">RESOURCE</span></code></pre>
<h2 id="utility-functions">Utility functions</h2>
<p>The name of the package is <strong>waylayUtil</strong>. This package provides 4 types of utility functions:</p>
<h3 id="function-to-retrieve-raw-data">function to retrieve raw data</h3>
<p>to retrieve rawData as JSON for a node “nodeName”</p>
<p><code>var rawData =  waylayUtil.getRawData(options, &quot;nodeName&quot;);</code></p>
<p>to retrieve parameter “parameterName” from rawData for node “nodeName”.</p>
<p><code>var param =  waylayUtil.getRawData(options, &quot;nodeName&quot;, &quot;parameterName&quot;);</code></p>
<p><strong>Important</strong> : unlike other calls in the util package, <strong>waylayUtil.getRawData throws the exception if the data is not available</strong>. Unlike (getStreamData, evaluateData, getCacheData) calls mentioned bellow that return undefined. The reason is that we assume that when you call getRawData you really expect this data always to be available to you. Otherwise, actuator, or other sensor that expect data from another sensor will not be functioning correctly. That also allows you to see the errors in a debugger window or in the Actuator logger.</p>
<p>Note: since the latest raw data result of every sensor is provided to all nodes in the network, you may as well want to do retrieve the previous result of the the sensor execution by doing this:</p>
<p><code>var rawData =  waylayUtil.getRawData(options, options.node.NAME);</code></p>
<p>This is exactly how <code>waylayUtil.getCacheData()</code> call has been implemented. See below;</p>
<h3 id="function-to-retrieve-cached-raw-data">function to retrieve cached raw data</h3>
<p><code>var rawData =  waylayUtil.getCacheData(options, &quot;latitude&quot;);</code> to retrieve parameter “latitude” from rawData of the node that invoke the script. This way you can for instance cache things that you need to retrieve only once (like location API).</p>
<p>For instance: you want to fetch geo location for a given address via the API service. Once the call is successful, in the result you can provide as the raw data “latitude” and “longitude”. Next time, these values will be automatically in the rawData of that node, so by simply calling <code>waylayUtil.getCacheData</code> on both parameters will give you this information, avoiding a need to call REST call again.</p>
<h3 id="function-to-retrieve-stream-data">function to retrieve stream data</h3>
<p><code>var rawData =  waylayUtil.getStreamData(options, &quot;latitude&quot;);</code> to retrieve parameter “latitude” from the stream data for the node that has resource matching the stream resource (which sends parameter “latitude”).</p>
<h3 id="function-to-retrieve-the-resource-name">function to retrieve the resource name</h3>
<p><code>var resourceName =  waylayUtil.getResource(options);</code></p>
<p>When you associate the sensor with a given resource name, you can use this function in the sensor code to retrieve that name. Please keep in mind that some words are reserved:</p>
<ul>
<li>$ (resource name will be inherited from the task resource name)</li>
<li>$taskId (resource name will be inherited from the task ID)</li>
</ul>
<p>This call will automatically translate $, $taskId into the runtime resource name.</p>
<h3 id="function-to-validate-e-mail">function to validate e-mail</h3>
<p><code>var boolean =  waylayUtil.validateEmail(&quot;test@gmail.com&quot;);</code> returns true if the input entry is a valid email address.</p>
<h3 id="function-to-retrieve-input-property">function to retrieve input property</h3>
<p><code>var rawData =  waylayUtil.getProperty(options, &quot;city&quot;);</code> to retrieve input parameter. This is a simple shortcut for the call: <code>options.requiredProperties.city</code>.</p>
<h3 id="function-to-evaluate-inputs">function to evaluate inputs</h3>
<p>It is done in a similar way as for the Function node:</p>
<p><code>var rawValue =  waylayUtil.evaluateData(options, input);</code> where input is in format:</p>
<p><code>&lt;node1.rawdat1&gt; or &lt;node1.rawdat1&gt; OPER &lt;node2.rawdat2&gt;</code> … The only difference is that you can’t make statistical computations like with a Function node.</p>
<p>This way, for instance, you can use data that comes from another sensor (make sure that you use the sequence option if the order of execution is important). Another thing you must keep in mind is that you can access any raw data from the node as well as its state. If you want to test this feature, without creating a template, you can always try something like this (in the sensor editor):</p>
<pre><code>options.rawData = {
  &quot;hello&quot; : 
  {   randomValue: 5,
      state: &quot;True&quot;
  },
  &quot;world&quot; : 
  {   randomValue: 2,
      state: &quot;True&quot;
  }
};
console.log(&quot;rawData sensor&quot;);
if(options.requiredProperties.formula) {
    try{
      //console.log(options);
      var rawValue =  waylayUtil.evaluateData(options, options.requiredProperties.formula);
      var value = {
        observedState: options.requiredProperties.threshold &gt; rawValue ? &quot;Above&quot;: &quot;Below&quot;,
        rawData:  {  rawValue: rawValue}  
      };
      //console.log(&quot;value was &quot; + rawValue);
      send(null, value);
    } catch(err){
        send(new Error(err));
    }
} else{
  send(new Error(&quot;Missing property testProperty1&quot;));
}</code></pre>
<p>and for instance, you define a formula like this in the editor:</p>
<p><code>&lt;hello.randomValue&gt; - &lt;world.randomValue&gt;</code></p>
<p>Note: just make sure that once you are OK with a sensor, to <strong>comment this line <code>\\options.rawData = {</code></strong> , otherwise you will always overwrite the task context of the rawData in your sensor!</p>
<h3 id="jsonpath-expression">JSONPath expression</h3>
<p>waylay util packages uses <a href="https://www.npmjs.com/package/node-red-contrib-jsonpath">JSONPath expression</a> to select rawdata.</p>
<p>Other examples (such as accessing the array of data points, or array of objects):</p>
<p><code>&lt;node1.temperature&gt; + &lt;node3.items[0].temperature&gt;</code></p>
<p>this way you can access the last point in the array:</p>
<p><code>&lt;node1.temperature&gt; + &lt;node3.items[(@.length-1)].temperature&gt;</code></p>
<p>If the array is array of objects, you can continue till the value you are interested in:</p>
<p><code>&lt;node1.temperature&gt; + &lt;node3.items2[(@.length-1)].item.temperature&gt;</code></p>
<p>You can also use selectors:</p>
<p><code>&lt;node3.items3[?(@.name == 'piet')].temperature&gt; + &lt;node3.items3[?(@.name == 'veselin')].temperature&gt;</code></p>
<p>You can also make a sentences this way (which is interesting thing to do if you want to send the actuator message with the content data from other sensors):</p>
<p><code>waylayUtil.evaluateData(options, &quot;Temperature is &lt;node3.items3[?(@.name == 'piet')].temperature&gt;)</code></p>
<p>If you want to filter on a parameter that is greater or lower than a particular value, you must use &amp;lt and &amp;gt notation, for instance get all temperatures with values greater than 23 degrees:</p>
<p><code>waylayUtil.evaluateData(options, &quot;&lt;node3.items3[?(@.temperature &amp;gt 23)].temperature&gt;)</code></p>
<p>You can also retrieve an array:</p>
<p><code>waylayUtil.evaluateData(options, &quot;&lt;node3.items.*&gt;&quot;)</code></p>
<p>There are also some small extensions to the library, mostly operations on arrays: To get a count of elements:</p>
<p><code>waylayUtil.evaluateData(options, &quot;&lt;node3.items[count]&gt;&quot;)</code></p>
<p>But you can also use some stats, in case that you select the array:</p>
<p><code>&lt;node3.data[max]&gt; - &lt;node3.data[min]&gt;</code></p>
<p>Or to produce a string from an array:</p>
<p><code>waylayUtil.evaluateData(options, &quot;&lt;node3.text[stringify]&gt;&quot;</code></p>
<p><code>waylayUtil.evaluateData(options, &quot;&lt;node3.text[stringify, and]&gt;&quot;</code></p>
<h3 id="function-to-template-inputs">function to template inputs</h3>
<p><code>waylayUtil.template(options, &quot;Hello {{node.rawID}}&quot;)</code></p>
<p>In case you want to use actuators such as e-mail, you might wish to create an HTML based content. In that case you might want to use template call rather than evaluateData call. Note also that in order to provide rawData input, we use other delimiters {{}}. For more info, please check <a href="http://handlebarsjs.com/">handlebarsjs documentation</a>. If you want to specify <em>resource</em> in template, use {{RESOURCE}}</p>
<p>We also provide few handlebars helper functions, which are annotated by {{{}}}:</p>
<ul>
<li>add, so you can do this {{{add node1.value node2.value}}}</li>
<li>subtract, so you can do this {{{subtract node1.value node2.value}}}</li>
<li>multiply, so you can do this {{{multiply node1.value node2.value}}}</li>
<li>divide, so you can do this {{{divide node1.value node2.value}}}</li>
<li>date, or day N, where N is positive or negative number, so you can do {{{date}}} or {{{date -1}}} for yesterday</li>
<li>time, local time {{{time}}}</li>
</ul>
<h3 id="distance-function">distance function</h3>
<p>You can use this function for nodes that have geo location in the raw data in format:</p>
<ul>
<li>longitude<br /></li>
<li>latitude.</li>
</ul>
<p>The easiest way to check this is by running a sensor and verifying rawData output after the execution.</p>
<p><code>var dist = waylayUtil.getDistance(options, &quot;nodeName1&quot;, &quot;nodeName2&quot;);</code></p>
<p>OR you can simply call the function this way, by providing all data yourself:</p>
<p><code>var dist = waylayUtil.getDistance(lat1, lon1, lat2, lon2);</code></p>
<h2 id="function-node">Function node</h2>
<p>The Function node operates on the raw data that is stored in the task context.</p>
<h3 id="function-computation">Function computation</h3>
<p>If you have correctly created the metadata file of your sensor plugin, then the function editor will autocomplete the raw data that it can use for calculation. In case you have not defined the raw data as part of the sensor metadata, you will need to type everything manually. The screenshot below shows the autocompletion: <img src="https://raw.githubusercontent.com/waylayio/documentation/master/images/formulaEditor.png" class="img-responsive"  /></p>
<p>The function processing has a number of built-in capabilities that are described below:</p>
<h3 id="built-in-functions">Built-in functions</h3>
<p>You can fetch the raw data from any node this way: <code>&lt;node.value1&gt;</code>. That allows you to do something like this: <code>abs( &lt;node.value1&gt; - &lt;node.value2&gt;)</code></p>
<p>You can use all built in functions available in exp4j: <a href="http://www.objecthunter.net/exp4j/#Built-in_functions">Exp4j syntax</a></p>
<p>Built-in functions:</p>
<ul>
<li>abs: absolute value</li>
<li>acos: arc cosine</li>
<li>asin: arc sine</li>
<li>atan: arc tangent</li>
<li>cbrt: cubic root</li>
<li>ceil: nearest upper integer</li>
<li>cos: cosine</li>
<li>cosh: hyperbolic cosine</li>
<li>exp: euler’s number raised to the power (e^x)</li>
<li>floor: nearest lower integer</li>
<li>log: logarithmus naturalis (base e)</li>
<li>log10: logarithm (base 10)</li>
<li>log2: logarithm (base 2)</li>
<li>sin: sine</li>
<li>sinh: hyperbolic sine</li>
<li>sqrt: square root</li>
<li>tan: tangent</li>
<li>tanh: hyperbolic tangent</li>
</ul>
<p>When raw data values are used in a function, arrows between their corresponding nodes and the function processing node will be auto-created by the waylay application: <img src="https://raw.githubusercontent.com/waylayio/documentation/master/images/formulaNodes.png" class="img-responsive"  /></p>
<p>Note that you should never try to connect sensors to the Function node, this is not going to work, just start typing the function in the Function node, that is all.</p>
<h3 id="using-previous-values">Using previous values</h3>
<p>You can also fetch the data from previous measurements using <code>[-n]</code> syntax:</p>
<p><code>&lt;node.value1&gt; - &lt;node.value1&gt;[-1]</code></p>
<p>In the example above <code>&lt;node.value1&gt;[-1]</code> means: the value of the raw data parameter <em>value1</em> at the previous invocation time.</p>
<h3 id="using-time-difference">Using time difference</h3>
<p>You can also use a delta in time between measurements in your function with <code>dt</code> like this:</p>
<p><code>abs( &lt;node.value1&gt; - &lt;node.value1&gt;[-1]) / dt</code> to get kind of first derivative computation</p>
<p><code>dt</code> is replaced by time delta between invocations in seconds</p>
<h3 id="statistical-computation">Statistical computation</h3>
<p>You can also use some extensions for statistics such as <code>min, max, avg, std, count</code> this way:</p>
<p><code>&lt;max(node.value1)&gt; - &lt;min(node.value1)&gt;</code></p>
<p><code>&lt;count(5, node.pressure)&gt;</code> or like string search:</p>
<p><code>&lt;count(Gent, node2.current_city)&gt;</code></p>
<ul>
<li>Statistics (avg, min, max, std) either takes 1 argument (value) or 3 arguments (number, [time/samples], value)</li>
<li>Count either takes 2 arguments(“searchKey”, value) or 4 arguments (“searchKey”, number, [time/samples], value)</li>
</ul>
<h3 id="aggregation-types">Aggregation types</h3>
<p>You have 3 types of aggregation:</p>
<ul>
<li>overall aggregation</li>
<li>by time</li>
<li>by number of samples</li>
</ul>
<p>You can also mix different types in one function like this:</p>
<p><code>&lt;max(3, minutes, node.value1)&gt; - &lt;min(5, samples, node2.value1)&gt;</code></p>
<p><code>&lt;max(3, samples, node.value1)&gt; - &lt;min(3, minutes, node2.value1)&gt;</code></p>
<p><code>&lt;count(5, 3, minutes, node.pressure)&gt;</code></p>
<p>You can also count the number of times a node was in a given state, for instance, the number of time a node was in the state “OK” for the last three samples:</p>
<p><code>&lt;count(OK, 3, samples, node.state)&gt;</code></p>
<p>Note: limitation is that you can’t mix different aggregation types(samples and time) for the same parameter. But you can use overall aggregation (without samples, or time) and combine it with one of other aggregation types(samples or time).</p>
<h3 id="distance-calculation">Distance calculation</h3>
<p>For any two nodes that return longitude and latitude via raw data, you can compute the distance using this function:</p>
<p><code>distance(node1,node2)</code></p>
<p>Distance is returned in km.</p>
<h3 id="sequence">Sequence</h3>
<p>You can also search for a sequence of states, if you want to monitor for changes of node states in time.</p>
<p><code>&lt;sequence([hello,world], node.state)&gt;</code></p>
<p>Function above will either return 1 or 0. 1 indicates that a match of the sequence has been found.</p>
<p>For instance, if you want to know whether 3 nodes will be in “hello,world” sequence, you can create function this way:</p>
<p><code>&lt;sequence([hello,world], node1.state)&gt;</code> + <code>&lt;sequence([hello,world], node2.state)&gt;</code> + <code>&lt;sequence([hello,world], node3.state)&gt;</code></p>
<p>and test whether the result equals 3.</p>
<h3 id="stream-data">Stream data</h3>
<p>In the waylay application, stream data is put in the GLOBAL context before sensor is executed (waylay takes care that that context is valid for each sensor). You can access it via in javascript: <code>options.rawData.GLOBAL.&lt;param&gt;</code> , nevertheless you should always use utility function as mentioned earlier to achieve the same:</p>
<p><code>var rawData =  waylayUtil.getStreamData(options, &quot;param&quot;);</code></p>
<p>In the Function node, you MUST omit options.rawData and use only this notation: <code>&lt;GLOBAL.param&gt;</code></p>
<p>Before deploying a new task, you can always check in the debug window that computation is actually happening. In the example below we used a dice sensor and couple of Function nodes. Note that you can as well put one Function node on top of others:</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/waylayio/documentation/master/images/formulaDebug.png" class="img-responsive"  />

</div>
<a href="#" class="scrollup"><a href="http://docs.waylay.io/"></a></a>

</div>
        </div>
                </div>
     <footer class="text-center">

        <div class="footer-below">
            <div class="container">
                <div class="row">
                    <div class="col-xs-9 pull-right">
                        Copyright &copy; waylay.io 2015
                    </div>
                </div>
            </div>
        </div>
    </footer>
    <script src="js/jquery-1.11.2.min.js"></script>
    <script src="js/jquery-ui-1.9.1.custom.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/jquery.tocify.min.js"></script>
    <script src="js/prettify.js"></script>
    <script src="js/tinynav.min.js"></script>
    <script src="js/freelancer.js"></script>
    <script src="js/simplemenu.js"> </script> 
</body>

</html>

